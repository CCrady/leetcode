-- https://leetcode.com/problems/permutations/

import Data.List hiding (permutations)

-- Copy-pasted from 0031.hs
splitAtLDS :: Ord a => [a] -> ([a], Maybe a, [a])
splitAtLDS = foldr lds' ([], Nothing, []) where
    lds' x ([], Nothing, [])   = ([], Nothing, [x])
    lds' x ([], Nothing, y:ys) | x >= y    = ([], Nothing, x:y:ys)
                               | otherwise = ([], Just x, y:ys)
    lds' x (xs, Just y,  zs)   = (x:xs, Just y, zs)

replaceFstGT :: Ord a => a -> [a] -> (a, [a])
replaceFstGT x (y:ys) | y > x     = (y, x:ys)
                      | otherwise = let
                            (rplcd, ys') = replaceFstGT x ys
                            in (rplcd, y:ys')

nextPermutation :: Ord a => [a] -> Maybe [a]
nextPermutation l = case splitAtLDS l of
    ([], Nothing, _)  -> Nothing
    (xs, Just y,  zs) -> let
        (y', zs') = replaceFstGT y $ reverse zs
        in Just $ xs ++ y' : zs'
-- End copy-pasted section

-- Given a function and a seed value, return the list generated by iterating the function on the
-- seed value. If the function ever returns Nothing, the list ends.
iterateUnfold :: (a -> Maybe a) -> a -> [a]
iterateUnfold f x = iterateUnfold' (Just x) where
    iterateUnfold' (Just y) = y : iterateUnfold' (f y)
    iterateUnfold' Nothing  = []

-- Lazily generates permutations by repeatedly calling nextPermutation. This requires the list's
-- elements to be orderable. If not all of the elements are unique by (==), it won't generate
-- duplicate permutations. It always generates the permutations in lexicographic order.
ver1 :: Ord a => [a] -> [[a]]
ver1 = iterateUnfold nextPermutation . sort


-- Return a list of pairs (x, xs) where x is an element of the input and xs is the input list sans
-- element x.
extractElements :: [a] -> [(a, [a])]
extractElements = extractElements' [] where
    extractElements' _    []     = []
    extractElements' prev (x:xs) = (x, prev ++ xs) : extractElements' (prev ++ [x]) xs

-- This version doesn't require its argument to be in Ord, but it's not as lazy as ver1. It doesn't
-- check for equality, so if not all of the list's elements are unique it will generate duplicate
-- permutations. The resulting list of permutations is in lexicographic order under an ordering
-- where earlier elements of the input list are less then later ones. This means that e.g. if the
-- input list is sorted, the output list of lists will be sorted too. The first element of the
-- output is always the input.
ver2 :: [a] -> [[a]]
ver2 [] = [[]]
-- this used to use a complicated nested map, but I made it clearer with a comprehension :O
ver2 xs = [y:perm | (y, ys) <- extractElements xs, perm <- ver2 ys]

-- Neither ver1 nor ver2 are the same as the implementation of permutations in the standard library.
-- I don't understand how that implementation works, though, so I'm not going to try to replicate
-- it.
-- https://stackoverflow.com/questions/24484348/what-does-this-list-permutations-implementation-in-haskell-exactly-do/24564307#24564307

